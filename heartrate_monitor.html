<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¹ãƒˆãƒ¬ã‚¹ãƒã‚§ãƒƒã‚«ãƒ¼ - åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼HRVè§£æ</title>
    
    <!-- iPhoneç”¨ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ« -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 500px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 14px;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .status.active {
            background: rgba(76, 175, 80, 0.3);
        }

        .measurement-timer {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .timer-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }

        .timer-value {
            font-size: 48px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .timer-label {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .timer-recommendation {
            font-size: 16px;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .timer-recommendation.reached {
            color: #4CAF50;
            font-weight: bold;
        }

        .timer-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .timer-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81c784);
            width: 0%;
            transition: width 0.3s ease;
        }

        .heart-rate-display {
            text-align: center;
            margin: 30px 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
        }

        .heart-rate-value {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .heart-rate-label {
            font-size: 18px;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .start-btn {
            background: #4CAF50;
            color: white;
        }

        .start-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #f44336;
            color: white;
        }

        .stop-btn:hover:not(:disabled) {
            background: #da190b;
            transform: translateY(-2px);
        }

        .export-btn {
            background: #2196F3;
            color: white;
        }

        .export-btn:hover:not(:disabled) {
            background: #0b7dda;
            transform: translateY(-2px);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            opacity: 0.8;
        }

        .info-value {
            font-weight: bold;
        }

        canvas {
            width: 100%;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 20px;
        }

        .analysis-result {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }

        .analysis-result h3 {
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        .analysis-result h4 {
            margin: 20px 0 10px 0;
            font-size: 16px;
            opacity: 0.9;
        }

        .pulse-wave-container,
        .ppi-container,
        .hrv-analysis {
            margin-bottom: 30px;
        }

        .hrv-analysis {
            margin-bottom: 30px;
        }

        .reliability-indicator {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .reliability-indicator.low {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid rgba(244, 67, 54, 0.5);
        }

        .reliability-indicator.medium {
            background: rgba(255, 152, 0, 0.2);
            border: 2px solid rgba(255, 152, 0, 0.5);
        }

        .reliability-indicator.good {
            background: rgba(33, 150, 243, 0.2);
            border: 2px solid rgba(33, 150, 243, 0.5);
        }

        .reliability-indicator.excellent {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid rgba(76, 175, 80, 0.5);
        }

        .reliability-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .reliability-value {
            font-size: 20px;
            font-weight: bold;
            margin: 0 10px;
        }

        .reliability-desc {
            font-size: 13px;
            opacity: 0.8;
            display: block;
            margin-top: 5px;
        }

        #pulseWaveCanvas,
        #ppiCanvas,
        #hrvCanvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .hrv-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .metric-card.stress-indicator {
            grid-column: 1 / -1;
            background: rgba(100, 200, 255, 0.2);
        }

        .metric-label {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .metric-desc {
            font-size: 12px;
            opacity: 0.7;
        }

        .stress-indicator.relaxed {
            background: rgba(76, 175, 80, 0.3);
        }

        .stress-indicator.normal {
            background: rgba(100, 200, 255, 0.3);
        }

        .stress-indicator.stressed {
            background: rgba(255, 152, 0, 0.3);
        }

        .stress-indicator.very-stressed {
            background: rgba(244, 67, 54, 0.3);
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .instructions h3 {
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .settings {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings h3 {
            margin-bottom: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        select, input[type="number"] {
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ’“ ã‚¹ãƒˆãƒ¬ã‚¹ãƒã‚§ãƒƒã‚«ãƒ¼</h1>
        <p class="subtitle">åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã§å¿ƒæ‹å¤‰å‹•ï¼ˆHRVï¼‰ã‚’æ¸¬å®šã—ã€è‡ªå¾‹ç¥çµŒãƒãƒ©ãƒ³ã‚¹ã¨ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹ã‚’è©•ä¾¡</p>

        <div class="status" id="status">
            ã‚»ãƒ³ã‚µãƒ¼æœªèµ·å‹•
        </div>

        <div class="measurement-timer" id="measurementTimer" style="display: none;">
            <div class="timer-display">
                <span class="timer-value" id="timerValue">0:00</span>
                <span class="timer-label">è¨ˆæ¸¬æ™‚é–“</span>
            </div>
            <div class="timer-recommendation" id="timerRecommendation">
                ç›®æ¨™: 5åˆ†ï¼ˆæ¨™æº–æ¸¬å®šï¼‰
            </div>
            <div class="timer-progress-bar">
                <div class="timer-progress-fill" id="timerProgressFill"></div>
            </div>
        </div>

        <div class="heart-rate-display">
            <div class="heart-rate-value" id="heartRate">--</div>
            <div class="heart-rate-label">BPM (æ‹/åˆ†)</div>
        </div>

        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">è¨ˆæ¸¬æ™‚é–“</span>
                <span class="info-value" id="duration">0ç§’</span>
            </div>
            <div class="info-row">
                <span class="info-label">ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ</span>
                <span class="info-value" id="sampleRate">-- Hz</span>
            </div>
            <div class="info-row">
                <span class="info-label">ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ</span>
                <span class="info-value" id="dataPoints">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">ä¿¡å·å“è³ª</span>
                <span class="info-value" id="signalQuality">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">å¹³å‡PPI</span>
                <span class="info-value" id="meanPPI">-- ms</span>
            </div>
            <div class="info-row">
                <span class="info-label">RMSSD (HRV)</span>
                <span class="info-value" id="rmssd">-- ms</span>
            </div>
        </div>

        <div class="settings">
            <h3>è¨­å®š</h3>
            <div class="setting-row">
                <label>æ¤œå‡ºæ–¹æ³•:</label>
                <select id="detectionMethod">
                    <option value="peak">ãƒ”ãƒ¼ã‚¯æ¤œå‡º</option>
                    <option value="autocorr">è‡ªå·±ç›¸é–¢</option>
                    <option value="fft">FFTï¼ˆå‘¨æ³¢æ•°è§£æï¼‰</option>
                    <option value="hybrid" selected>ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰</option>
                </select>
            </div>
            <div class="setting-row">
                <label>ãƒ•ã‚£ãƒ«ã‚¿å¼·åº¦:</label>
                <select id="filterStrength">
                    <option value="low">å¼±</option>
                    <option value="medium" selected>ä¸­</option>
                    <option value="high">å¼·</option>
                </select>
            </div>
            <div class="setting-row">
                <label>æ›´æ–°é–“éš”:</label>
                <select id="updateInterval">
                    <option value="2000">2ç§’</option>
                    <option value="3000" selected>3ç§’</option>
                    <option value="5000">5ç§’</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button class="start-btn" id="startBtn" onclick="startMeasurement()">è¨ˆæ¸¬é–‹å§‹</button>
            <button class="stop-btn" id="stopBtn" onclick="stopMeasurement()" disabled>åœæ­¢</button>
        </div>

        <button class="export-btn" id="exportBtn" onclick="exportData()" disabled>ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>

        <canvas id="waveform"></canvas>

        <div class="analysis-result" id="analysisResult" style="display: none;">
            <h3>ğŸ“Š è¨ˆæ¸¬çµæœ</h3>
            
            <div class="pulse-wave-container">
                <h4>è„ˆæ³¢ï¼ˆåŠ é€Ÿåº¦ä¿¡å·ï¼‰</h4>
                <canvas id="pulseWaveCanvas"></canvas>
            </div>

            <div class="ppi-container">
                <h4>PPIæ™‚ç³»åˆ—</h4>
                <canvas id="ppiCanvas"></canvas>
            </div>

            <div class="hrv-analysis">
                <h4>HRVå‘¨æ³¢æ•°è§£æï¼ˆLF/HFï¼‰</h4>
                
                <div class="reliability-indicator" id="reliabilityIndicator">
                    <span class="reliability-label">æ¸¬å®šä¿¡é ¼æ€§:</span>
                    <span class="reliability-value" id="reliabilityValue">--</span>
                    <span class="reliability-desc" id="reliabilityDesc">--</span>
                </div>

                <canvas id="hrvCanvas"></canvas>
                
                <div class="hrv-metrics">
                    <div class="metric-card">
                        <div class="metric-label">LF (Low Frequency)</div>
                        <div class="metric-value" id="lfValue">-- msÂ²</div>
                        <div class="metric-desc">0.04-0.15 Hzï¼ˆäº¤æ„Ÿç¥çµŒï¼‹å‰¯äº¤æ„Ÿç¥çµŒï¼‰</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">HF (High Frequency)</div>
                        <div class="metric-value" id="hfValue">-- msÂ²</div>
                        <div class="metric-desc">0.15-0.40 Hzï¼ˆå‰¯äº¤æ„Ÿç¥çµŒï¼‰</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">LF/HFæ¯”</div>
                        <div class="metric-value" id="lfhfRatio">--</div>
                        <div class="metric-desc">äº¤æ„Ÿç¥çµŒæ´»å‹•ã®æŒ‡æ¨™</div>
                    </div>
                    <div class="metric-card stress-indicator" id="stressIndicator">
                        <div class="metric-label">è‡ªå¾‹ç¥çµŒçŠ¶æ…‹</div>
                        <div class="metric-value" id="stressLevel">--</div>
                        <div class="metric-desc" id="stressDesc">--</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h3>ğŸ“± ã‚¹ãƒˆãƒ¬ã‚¹ãƒã‚§ãƒƒã‚¯ã®æ–¹æ³•</h3>
            <ol>
                <li><strong>é‡è¦:</strong> HTTPSã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ï¼ˆiOSã®å ´åˆå¿…é ˆï¼‰</li>
                <li>ä»°å‘ã‘ã«å¯ã¦ã€èƒ¸ã®ä¸­å¤®ã«ã‚¹ãƒãƒ›ã‚’ç½®ã</li>
                <li>ã‚¹ãƒãƒ›ãŒå¿ƒè‡“ã®å‹•ãã§æŒ¯å‹•ã™ã‚‹ã‚ˆã†ã«ä½ç½®ã‚’èª¿æ•´</li>
                <li>ã€Œè¨ˆæ¸¬é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™</li>
                <li><strong>iOSã®å ´åˆ:</strong> ã‚»ãƒ³ã‚µãƒ¼ä½¿ç”¨è¨±å¯ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€Œè¨±å¯ã€ã‚’ã‚¿ãƒƒãƒ—</li>
                <li>é™ã‹ã«å‘¼å¸ã—ã€å‹•ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹</li>
                <li><strong>æ¨å¥¨è¨ˆæ¸¬æ™‚é–“ã¾ã§å¾…ã¤</strong>ï¼ˆä¸‹è¨˜å‚ç…§ï¼‰</li>
                <li>ã€Œè¨ˆæ¸¬åœæ­¢ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦<strong>ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹</strong>ã‚’ç¢ºèª</li>
            </ol>
            
            <div style="margin-top: 20px; padding: 15px; background: rgba(100, 200, 255, 0.2); border-radius: 8px;">
                <h4 style="margin-bottom: 10px;">â±ï¸ ã‚¹ãƒˆãƒ¬ã‚¹è©•ä¾¡ã®æ¨å¥¨è¨ˆæ¸¬æ™‚é–“</h4>
                <div style="margin-left: 10px; line-height: 1.8;">
                    â€¢ <strong>2ã€œ3åˆ†</strong>: ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ï¼ˆå‚è€ƒå€¤ï¼‰<br>
                    â€¢ <strong>5åˆ†</strong>: â­ æ¨™æº–æ¸¬å®šï¼ˆæ¨å¥¨ï¼‰<br>
                    â€¢ <strong>10åˆ†ä»¥ä¸Š</strong>: é«˜ç²¾åº¦æ¸¬å®šï¼ˆç ”ç©¶ãƒ¬ãƒ™ãƒ«ï¼‰<br>
                </div>
                <div style="margin-top: 10px; font-size: 13px; opacity: 0.9;">
                    â€» æ­£ç¢ºãªã‚¹ãƒˆãƒ¬ã‚¹è©•ä¾¡ï¼ˆLF/HFæ¯”ï¼‰ã«ã¯ã€<br>
                    ã€€æœ€ä½ã§ã‚‚5åˆ†é–“ã®è¨ˆæ¸¬ãŒå¿…è¦ã§ã™ã€‚
                </div>
            </div>

            <div style="margin-top: 15px; padding: 15px; background: rgba(150, 255, 150, 0.2); border-radius: 8px;">
                <h4 style="margin-bottom: 10px;">ğŸ’¡ ã“ã®ã‚¢ãƒ—ãƒªã§ã‚ã‹ã‚‹ã“ã¨</h4>
                <div style="margin-left: 10px; line-height: 1.8;">
                    â€¢ <strong>å¿ƒæ‹æ•°ï¼ˆBPMï¼‰</strong>: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¿ƒæ‹æ¸¬å®š<br>
                    â€¢ <strong>PPI</strong>: å¿ƒæ‹é–“éš”ã®å¤‰å‹•ã‚’å¯è¦–åŒ–<br>
                    â€¢ <strong>HRVè§£æ</strong>: LF/HFæ¯”ã‹ã‚‰è‡ªå¾‹ç¥çµŒãƒãƒ©ãƒ³ã‚¹ã‚’è©•ä¾¡<br>
                    â€¢ <strong>ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹</strong>: ãƒªãƒ©ãƒƒã‚¯ã‚¹/æ­£å¸¸/ã‚¹ãƒˆãƒ¬ã‚¹ã‚’åˆ¤å®š<br>
                </div>
            </div>

            <div style="margin-top: 15px; padding: 10px; background: rgba(255, 200, 0, 0.2); border-radius: 5px;">
                <strong>âš ï¸ iOSä½¿ç”¨æ™‚ã®æ³¨æ„:</strong><br>
                â€¢ Safari ã¾ãŸã¯ Chrome ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„<br>
                â€¢ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™ï¼ˆlocalhostä»¥å¤–ï¼‰<br>
                â€¢ ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã¯å¿…ãšã€Œè¨±å¯ã€ã‚’é¸ã‚“ã§ãã ã•ã„<br>
                â€¢ æ‹’å¦ã—ãŸå ´åˆã¯ã€Safariã®è¨­å®šâ†’Webã‚µã‚¤ãƒˆã®è¨­å®šã‹ã‚‰å¤‰æ›´ã§ãã¾ã™
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let isRecording = false;
        let accelerometerData = [];
        let ppiData = []; // PPIï¼ˆãƒ”ãƒ¼ã‚¯é–“éš”ï¼‰ãƒ‡ãƒ¼ã‚¿
        let processedSignalData = []; // å‰å‡¦ç†æ¸ˆã¿ä¿¡å·ãƒ‡ãƒ¼ã‚¿
        let hrvResult = null; // HRVè§£æçµæœ
        let startTime = null;
        let animationFrame = null;
        let sensorInterval = null;
        let analysisInterval = null;
        let lastTimestamp = null;
        let sampleRates = [];
        let targetSampleRate = 100; // ç›®æ¨™ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ 100Hz
        let sensorData = { x: 0, y: 0, z: 0 }; // æœ€æ–°ã®ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿
        let lastSampleTime = 0;

        // Canvasè¨­å®šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼‰
        let canvas = null;
        let ctx = null;

        // åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®åˆæœŸåŒ–ã¨è¨ˆæ¸¬é–‹å§‹
        async function startMeasurement() {
            console.log('========================================');
            console.log('è¨ˆæ¸¬é–‹å§‹ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
            console.log('ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—:', new Date().toISOString());
            console.log('ç¾åœ¨ã®URL:', window.location.href);
            console.log('ãƒ—ãƒ­ãƒˆã‚³ãƒ«:', window.location.protocol);
            console.log('ãƒ›ã‚¹ãƒˆå:', window.location.hostname);
            console.log('========================================');
            
            // å³åº§ã«è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            document.getElementById('status').textContent = 'å‡¦ç†ä¸­...';
            document.getElementById('status').style.background = 'rgba(33, 150, 243, 0.3)';
            
            // HTTPSãƒã‚§ãƒƒã‚¯ï¼ˆlocalhostã€127.0.0.1ã€file://ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯è¨±å¯ï¼‰
            const isLocalOrFile = window.location.protocol === 'file:' || 
                                 window.location.hostname === 'localhost' || 
                                 window.location.hostname === '127.0.0.1' ||
                                 window.location.hostname === '';
            
            if (window.location.protocol !== 'https:' && !isLocalOrFile) {
                alert('âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™\n\niOSã§ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€HTTPSçµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n\nå¯¾å‡¦æ³•:\n1. GitHub Pagesã€Netlifyã€Vercelãªã©ã«ãƒ‡ãƒ—ãƒ­ã‚¤\n2. ãƒ­ãƒ¼ã‚«ãƒ«HTTPSã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨\n3. ngrokãªã©ã®ãƒˆãƒ³ãƒãƒ«ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨');
                console.error('HTTPSæ¥ç¶šã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            console.log('ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒã‚§ãƒƒã‚¯é€šé:', window.location.protocol);
            
            try {
                // iOS 13+ ã®å ´åˆã¯è¨±å¯ãŒå¿…è¦
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    console.log('iOS: ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...');
                    document.getElementById('status').textContent = 'è¨±å¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„...';
                    
                    try {
                        const permission = await DeviceMotionEvent.requestPermission();
                        console.log('è¨±å¯çµæœ:', permission);
                        
                        if (permission !== 'granted') {
                            const message = 
                                'âŒ ã‚»ãƒ³ã‚µãƒ¼ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ\n\n' +
                                'å¯¾å‡¦æ³•:\n' +
                                '1. Safariã®è¨­å®šã‚’é–‹ã\n' +
                                '2. ä¸‹ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦ã€Œãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€â†’ã€Œãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚ªãƒªã‚¨ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¯ã‚»ã‚¹ã€ã‚’æ¢ã™\n' +
                                '3. ã“ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‚’ã€Œè¨±å¯ã€ã«å¤‰æ›´\n' +
                                '4. ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã€ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„\n\n' +
                                'ã¾ãŸã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã“ã®ãƒšãƒ¼ã‚¸ã‚’é–‹ãç›´ã—ã¦ãã ã•ã„ã€‚';
                            
                            alert(message);
                            console.error('è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ');
                            document.getElementById('status').textContent = 'ã‚»ãƒ³ã‚µãƒ¼ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ';
                            return;
                        }
                    } catch (permError) {
                        console.error('è¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', permError);
                        alert('è¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + permError.message + '\n\nHTTPSæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                        return;
                    }
                } else {
                    console.log('Android/ãã®ä»–: è¨±å¯ä¸è¦');
                }

                isRecording = true;
                accelerometerData = [];
                ppiData = [];
                processedSignalData = [];
                hrvResult = null;
                startTime = Date.now();
                lastTimestamp = Date.now();
                sampleRates = [];

                // è§£æçµæœã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤º
                document.getElementById('analysisResult').style.display = 'none';

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('exportBtn').disabled = true;
                document.getElementById('status').textContent = 'è¨ˆæ¸¬ä¸­... ãƒ‡ãƒ¼ã‚¿å¾…æ©Ÿä¸­';
                document.getElementById('status').classList.add('active');

                // è¨ˆæ¸¬ã‚¿ã‚¤ãƒãƒ¼ã‚’è¡¨ç¤º
                document.getElementById('measurementTimer').style.display = 'block';

                console.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²ã—ã¾ã™');
                // åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆé«˜é »åº¦ã§ãƒ‡ãƒ¼ã‚¿å—ä¿¡ï¼‰
                window.addEventListener('devicemotion', handleMotionEvent, true);

                // 100Hzã§å®šæœŸçš„ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆ10msã”ã¨ï¼‰
                sensorInterval = setInterval(sampleAtFixedRate, 10);

                // ã‚»ãƒ³ã‚µãƒ¼ãŒå‹•ä½œã—ã¦ã„ã‚‹ã‹ç¢ºèª
                setTimeout(() => {
                    if (accelerometerData.length === 0) {
                        console.warn('5ç§’çµŒéã—ã¦ã‚‚ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¦ã„ã¾ã›ã‚“');
                        document.getElementById('status').textContent = 'âš ï¸ ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãªã—ï¼ˆã‚¹ãƒãƒ›ã‚’è»½ãå‹•ã‹ã—ã¦ã¿ã¦ãã ã•ã„ï¼‰';
                    } else {
                        console.log('ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ:', accelerometerData.length, 'ä»¶');
                        document.getElementById('status').textContent = 'âœ“ è¨ˆæ¸¬ä¸­ï¼ˆãƒ‡ãƒ¼ã‚¿å–å¾—OKï¼‰';
                    }
                }, 5000);

                // å®šæœŸçš„ãªå¿ƒæ‹è§£æ
                const updateInterval = parseInt(document.getElementById('updateInterval').value);
                analysisInterval = setInterval(analyzeHeartRate, updateInterval);

                // UIæ›´æ–°
                requestAnimationFrame(updateUI);

                console.log('è¨ˆæ¸¬é–‹å§‹å®Œäº†');

            } catch (error) {
                console.error('ã‚»ãƒ³ã‚µãƒ¼èµ·å‹•ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚»ãƒ³ã‚µãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message + '\n\nè©³ç´°ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                isRecording = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'ã‚¨ãƒ©ãƒ¼: ' + error.message;
            }
        }

        // åŠ é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ï¼ˆã‚»ãƒ³ã‚µãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¯é«˜é »åº¦ã§ç™ºç”Ÿï¼‰
        function handleMotionEvent(event) {
            if (!isRecording) return;

            const acc = event.accelerationIncludingGravity;
            
            if (acc && acc.x !== null && acc.y !== null && acc.z !== null) {
                // æœ€æ–°ã®ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆé«˜é »åº¦ã§æ›´æ–°ï¼‰
                sensorData.x = acc.x;
                sensorData.y = acc.y;
                sensorData.z = acc.z;
            } else {
                if (accelerometerData.length < 5) {
                    console.warn('ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒnullã§ã™:', acc);
                }
            }
        }

        // 100Hzã§å®šæœŸçš„ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        function sampleAtFixedRate() {
            if (!isRecording) return;

            const currentTime = Date.now();
            
            // åˆå›ã®ã¿ãƒ­ã‚°å‡ºåŠ›
            if (accelerometerData.length === 0) {
                console.log('100Hzã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–‹å§‹:', sensorData);
            }

            // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
            if (lastSampleTime > 0) {
                const actualRate = 1000 / (currentTime - lastSampleTime);
                sampleRates.push(actualRate);
                if (sampleRates.length > 50) sampleRates.shift();
            }
            lastSampleTime = currentTime;

            // 3è»¸ã®åˆæˆåŠ é€Ÿåº¦ï¼ˆãƒãƒ«ãƒ ï¼‰
            const magnitude = Math.sqrt(
                sensorData.x * sensorData.x + 
                sensorData.y * sensorData.y + 
                sensorData.z * sensorData.z
            );
            
            accelerometerData.push({
                timestamp: currentTime,
                x: sensorData.x,
                y: sensorData.y,
                z: sensorData.z,
                magnitude: magnitude
            });

            // 100ä»¶ã”ã¨ã«ãƒ­ã‚°
            if (accelerometerData.length % 100 === 0) {
                const avgRate = sampleRates.length > 0 
                    ? Math.round(sampleRates.reduce((a,b) => a+b, 0) / sampleRates.length)
                    : 0;
                console.log('ãƒ‡ãƒ¼ã‚¿ä»¶æ•°:', accelerometerData.length, 'å¹³å‡ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ:', avgRate, 'Hz');
            }

            // ãƒ¡ãƒ¢ãƒªç®¡ç†ï¼š30ç§’ä»¥ä¸Šå¤ã„ãƒ‡ãƒ¼ã‚¿ã¯å‰Šé™¤
            const cutoffTime = currentTime - 30000;
            accelerometerData = accelerometerData.filter(d => d.timestamp > cutoffTime);
        }

        // è¨ˆæ¸¬åœæ­¢
        function stopMeasurement() {
            console.log('è¨ˆæ¸¬åœæ­¢');
            isRecording = false;
            window.removeEventListener('devicemotion', handleMotionEvent, true);
            
            if (sensorInterval) {
                clearInterval(sensorInterval);
                sensorInterval = null;
            }
            
            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            }

            console.log('æœ€çµ‚ãƒ‡ãƒ¼ã‚¿ä»¶æ•°:', accelerometerData.length);
            console.log('PPIä»¶æ•°:', ppiData.length);

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('status').textContent = 'è¨ˆæ¸¬åœæ­¢ï¼ˆãƒ‡ãƒ¼ã‚¿: ' + accelerometerData.length + 'ä»¶ï¼‰';
            document.getElementById('status').classList.remove('active');

            // è¨ˆæ¸¬ã‚¿ã‚¤ãƒãƒ¼ã‚’éè¡¨ç¤º
            document.getElementById('measurementTimer').style.display = 'none';

            // æœ€çµ‚è§£æã‚’å®Ÿè¡Œ
            performFinalAnalysis();
        }

        // æœ€çµ‚è§£æï¼ˆåœæ­¢å¾Œï¼‰
        function performFinalAnalysis() {
            console.log('=== æœ€çµ‚è§£æé–‹å§‹ ===');

            // è¨ˆæ¸¬æ™‚é–“ã‚’è¨ˆç®—
            const measurementDuration = Math.floor((Date.now() - startTime) / 1000);
            console.log('è¨ˆæ¸¬æ™‚é–“:', measurementDuration, 'ç§’');

            // ä¿¡é ¼æ€§è©•ä¾¡
            const reliability = assessMeasurementReliability(measurementDuration);
            console.log('ä¿¡é ¼æ€§è©•ä¾¡:', reliability);

            // è§£æçµæœã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
            document.getElementById('analysisResult').style.display = 'block';

            // 1. è„ˆæ³¢ï¼ˆå‰å‡¦ç†æ¸ˆã¿ä¿¡å·ï¼‰ã‚’è¡¨ç¤º
            if (processedSignalData.length > 0) {
                drawPulseWave(processedSignalData);
            }

            // 2. PPIæ™‚ç³»åˆ—ã‚’è¡¨ç¤º
            if (ppiData.length > 0) {
                drawPPITimeSeries(ppiData);

                // 3. HRVå‘¨æ³¢æ•°è§£æ
                hrvResult = analyzeHRVFrequency(ppiData);
                
                if (hrvResult) {
                    // ä¿¡é ¼æ€§ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
                    const reliabilityIndicator = document.getElementById('reliabilityIndicator');
                    reliabilityIndicator.className = 'reliability-indicator ' + reliability.class;
                    document.getElementById('reliabilityValue').textContent = reliability.level;
                    document.getElementById('reliabilityDesc').textContent = reliability.description;

                    // HRVã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’æç”»
                    drawHRVSpectrum(hrvResult);

                    // LF/HFæŒ‡æ¨™ã‚’è¡¨ç¤º
                    document.getElementById('lfValue').textContent = hrvResult.lfPower.toFixed(2) + ' msÂ²';
                    document.getElementById('hfValue').textContent = hrvResult.hfPower.toFixed(2) + ' msÂ²';
                    document.getElementById('lfhfRatio').textContent = hrvResult.lfhfRatio.toFixed(2);

                    // ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹ã‚’åˆ¤å®šãƒ»è¡¨ç¤º
                    const stressAssessment = assessStressLevel(hrvResult.lfhfRatio);
                    const stressIndicator = document.getElementById('stressIndicator');
                    
                    // æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
                    stressIndicator.classList.remove('relaxed', 'normal', 'stressed', 'very-stressed');
                    // æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                    stressIndicator.classList.add(stressAssessment.class);
                    
                    document.getElementById('stressLevel').textContent = stressAssessment.level;
                    
                    // ä¿¡é ¼æ€§ã«å¿œã˜ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª¿æ•´
                    let stressDescription = stressAssessment.description;
                    if (reliability.score < 3) {
                        stressDescription += '\nâ€» ã‚ˆã‚Šæ­£ç¢ºãªè©•ä¾¡ã«ã¯5åˆ†ä»¥ä¸Šã®è¨ˆæ¸¬ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
                    }
                    document.getElementById('stressDesc').textContent = stressDescription;

                    console.log('HRVè§£æå®Œäº†:', {
                        LF: hrvResult.lfPower.toFixed(2),
                        HF: hrvResult.hfPower.toFixed(2),
                        'LF/HF': hrvResult.lfhfRatio.toFixed(2),
                        çŠ¶æ…‹: stressAssessment.level,
                        ä¿¡é ¼æ€§: reliability.level
                    });
                } else {
                    console.log('HRVè§£æ: ãƒ‡ãƒ¼ã‚¿ä¸è¶³');
                    
                    // ä¿¡é ¼æ€§ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã«ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
                    const reliabilityIndicator = document.getElementById('reliabilityIndicator');
                    reliabilityIndicator.className = 'reliability-indicator low';
                    document.getElementById('reliabilityValue').textContent = 'è§£æä¸å¯';
                    document.getElementById('reliabilityDesc').textContent = 'PPIãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆæœ€ä½30å€‹å¿…è¦ï¼‰ã€‚ã‚ˆã‚Šé•·ã„æ™‚é–“ã®è¨ˆæ¸¬ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚';
                    
                    document.getElementById('lfValue').textContent = 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³';
                    document.getElementById('hfValue').textContent = 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³';
                    document.getElementById('lfhfRatio').textContent = '--';
                    document.getElementById('stressLevel').textContent = 'è§£æä¸å¯';
                    document.getElementById('stressDesc').textContent = 'PPIãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆæœ€ä½30å€‹å¿…è¦ï¼‰';
                }
            } else {
                console.log('PPIãƒ‡ãƒ¼ã‚¿ãªã—');
                
                // ä¿¡é ¼æ€§ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã«ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
                const reliabilityIndicator = document.getElementById('reliabilityIndicator');
                reliabilityIndicator.className = 'reliability-indicator low';
                document.getElementById('reliabilityValue').textContent = 'ãƒ‡ãƒ¼ã‚¿ãªã—';
                document.getElementById('reliabilityDesc').textContent = 'PPIãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ãƒãƒ›ã®ä½ç½®ã‚’èª¿æ•´ã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
                
                document.getElementById('stressLevel').textContent = 'ãƒ‡ãƒ¼ã‚¿ãªã—';
                document.getElementById('stressDesc').textContent = 'PPIãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ';
            }

            console.log('=== æœ€çµ‚è§£æå®Œäº† ===');
        }

        // è„ˆæ³¢ï¼ˆå‰å‡¦ç†æ¸ˆã¿ä¿¡å·ï¼‰ã‚’æç”»
        function drawPulseWave(signal) {
            const canvas = document.getElementById('pulseWaveCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 400;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!signal || signal.length < 2) return;

            // è¡¨ç¤ºã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«æ•°ï¼ˆæœ€å¤§1000ç‚¹ï¼‰
            const maxPoints = 1000;
            const step = Math.ceil(signal.length / maxPoints);
            const displaySignal = [];
            for (let i = 0; i < signal.length; i += step) {
                displaySignal.push(signal[i]);
            }

            // æ­£è¦åŒ–
            const validSignal = displaySignal.filter(x => isFinite(x));
            if (validSignal.length === 0) return;

            const maxVal = Math.max(...validSignal);
            const minVal = Math.min(...validSignal);
            const range = maxVal - minVal || 1;
            const normalized = displaySignal.map(x => (x - minVal) / range);

            // æç”»
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < normalized.length; i++) {
                const x = (i / normalized.length) * canvas.width;
                const y = canvas.height - (normalized[i] * canvas.height * 0.8 + canvas.height * 0.1);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // ã‚°ãƒªãƒƒãƒ‰ç·š
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // PPIæ™‚ç³»åˆ—ã‚’æç”»
        function drawPPITimeSeries(ppiData) {
            const canvas = document.getElementById('ppiCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 400;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!ppiData || ppiData.length < 2) return;

            // PPIå€¤ã‚’å–å¾—
            const intervals = ppiData.map(p => p.interval);
            const maxPPI = Math.max(...intervals);
            const minPPI = Math.min(...intervals);
            const range = maxPPI - minPPI || 1;

            // æç”»
            ctx.strokeStyle = '#81c784';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < ppiData.length; i++) {
                const x = (i / (ppiData.length - 1)) * canvas.width;
                const normalized = (ppiData[i].interval - minPPI) / range;
                const y = canvas.height - (normalized * canvas.height * 0.8 + canvas.height * 0.1);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // ãƒã‚¤ãƒ³ãƒˆã‚’æç”»
            ctx.fillStyle = '#81c784';
            for (let i = 0; i < ppiData.length; i++) {
                const x = (i / (ppiData.length - 1)) * canvas.width;
                const normalized = (ppiData[i].interval - minPPI) / range;
                const y = canvas.height - (normalized * canvas.height * 0.8 + canvas.height * 0.1);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // ã‚°ãƒªãƒƒãƒ‰ç·šã¨ãƒ©ãƒ™ãƒ«
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '24px sans-serif';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();

                const value = maxPPI - (i / 4) * range;
                ctx.fillText(Math.round(value) + 'ms', 10, y - 5);
            }
        }

        // HRVã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’æç”»
        function drawHRVSpectrum(hrvResult) {
            const canvas = document.getElementById('hrvCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 400;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { powerSpectrum, frequencies } = hrvResult;

            // 0-0.5 Hzã®ç¯„å›²ã®ã¿è¡¨ç¤º
            const maxFreq = 0.5;
            const displayIndices = [];
            const displayPower = [];

            for (let i = 0; i < frequencies.length; i++) {
                if (frequencies[i] <= maxFreq) {
                    displayIndices.push(i);
                    displayPower.push(powerSpectrum[i]);
                }
            }

            if (displayPower.length === 0) return;

            const maxPower = Math.max(...displayPower);

            // ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’æç”»ï¼ˆæ£’ã‚°ãƒ©ãƒ•ï¼‰
            const barWidth = canvas.width / displayPower.length;

            for (let i = 0; i < displayPower.length; i++) {
                const freq = frequencies[displayIndices[i]];
                const x = (freq / maxFreq) * canvas.width;
                const height = (displayPower[i] / maxPower) * canvas.height * 0.9;
                const y = canvas.height - height;

                // LFå¸¯åŸŸï¼ˆ0.04-0.15 Hzï¼‰ã¯é’è‰²
                if (freq >= 0.04 && freq <= 0.15) {
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.7)';
                }
                // HFå¸¯åŸŸï¼ˆ0.15-0.40 Hzï¼‰ã¯ç·‘è‰²
                else if (freq >= 0.15 && freq <= 0.40) {
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
                }
                // ãã®ä»–ã¯ç°è‰²
                else {
                    ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                }

                ctx.fillRect(x, y, barWidth, height);
            }

            // LF/HFå¸¯åŸŸã®å¢ƒç•Œç·š
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // LFä¸‹é™ï¼ˆ0.04 Hzï¼‰
            let xLine = (0.04 / maxFreq) * canvas.width;
            ctx.beginPath();
            ctx.moveTo(xLine, 0);
            ctx.lineTo(xLine, canvas.height);
            ctx.stroke();

            // LF/HFå¢ƒç•Œï¼ˆ0.15 Hzï¼‰
            xLine = (0.15 / maxFreq) * canvas.width;
            ctx.beginPath();
            ctx.moveTo(xLine, 0);
            ctx.lineTo(xLine, canvas.height);
            ctx.stroke();

            // HFä¸Šé™ï¼ˆ0.40 Hzï¼‰
            xLine = (0.40 / maxFreq) * canvas.width;
            ctx.beginPath();
            ctx.moveTo(xLine, 0);
            ctx.lineTo(xLine, canvas.height);
            ctx.stroke();

            ctx.setLineDash([]);

            // ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('LF', (0.095 / maxFreq) * canvas.width, 40);
            ctx.fillText('HF', (0.275 / maxFreq) * canvas.width, 40);

            // Xè»¸ãƒ©ãƒ™ãƒ«
            ctx.font = '24px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let f = 0; f <= maxFreq; f += 0.1) {
                const x = (f / maxFreq) * canvas.width;
                ctx.fillText(f.toFixed(1) + 'Hz', x, canvas.height - 10);
            }
        }

        // å‰å‡¦ç†ï¼šDCé™¤å»ã¨å¸¯åŸŸãƒ•ã‚£ãƒ«ã‚¿
        function preprocessSignal(data) {
            try {
                if (data.length < 10) return [];

                // åŠ é€Ÿåº¦ã®ãƒãƒ«ãƒ ã‚’ä½¿ç”¨
                let signal = data.map(d => d.magnitude).filter(x => isFinite(x));
                
                if (signal.length < 10) return [];

                // DCæˆåˆ†é™¤å»ï¼ˆå¹³å‡ã‚’å¼•ãï¼‰
                const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
                signal = signal.map(x => x - mean);

                // ç°¡æ˜“çš„ãªãƒãƒ³ãƒ‰ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆ0.7Hz - 4Hzï¼šå¿ƒæ‹ã®å‘¨æ³¢æ•°å¸¯åŸŸï¼‰
                const filterStrength = document.getElementById('filterStrength').value;
                const windowSize = filterStrength === 'low' ? 3 : filterStrength === 'high' ? 7 : 5;
                
                // ç§»å‹•å¹³å‡ã«ã‚ˆã‚‹é«˜å‘¨æ³¢ãƒã‚¤ã‚ºé™¤å»
                let filtered = [];
                for (let i = 0; i < signal.length; i++) {
                    let sum = 0;
                    let count = 0;
                    const halfWindow = Math.floor(windowSize / 2);
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(signal.length - 1, i + halfWindow); j++) {
                        if (isFinite(signal[j])) {
                            sum += signal[j];
                            count++;
                        }
                    }
                    if (count > 0) {
                        filtered.push(sum / count);
                    }
                }

                return filtered.filter(x => isFinite(x));
            } catch (error) {
                console.error('å‰å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                return [];
            }
        }

        // FFTã‚’ä½¿ã£ãŸå‘¨æ³¢æ•°è§£æ
        function fftHeartRate(signal, sampleRate) {
            try {
                if (signal.length < 64) return null;

                // FFTï¼ˆç°¡æ˜“ç‰ˆ - DFTå®Ÿè£…ï¼‰
                const N = Math.min(256, Math.pow(2, Math.floor(Math.log2(signal.length))));
                const fft = new Array(N).fill(0);
                
                // è¨ˆç®—è² è·ã‚’æ¸›ã‚‰ã™ãŸã‚ã€ä¸€éƒ¨ã®å‘¨æ³¢æ•°ã®ã¿è¨ˆç®—
                const minFreq = 0.7;
                const maxFreq = 4.0;
                const minBin = Math.floor(minFreq * N / sampleRate);
                const maxBin = Math.ceil(maxFreq * N / sampleRate);

                for (let k = minBin; k < maxBin && k < N; k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < N && n < signal.length; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += signal[n] * Math.cos(angle);
                        imag += signal[n] * Math.sin(angle);
                    }
                    fft[k] = Math.sqrt(real * real + imag * imag);
                }

                // æœ€å¤§ãƒ‘ãƒ¯ãƒ¼ã®å‘¨æ³¢æ•°ã‚’æ¤œå‡º
                let maxPower = 0;
                let maxFreqBin = 0;
                for (let i = minBin; i < maxBin && i < fft.length; i++) {
                    if (fft[i] > maxPower) {
                        maxPower = fft[i];
                        maxFreqBin = i;
                    }
                }

                if (maxFreqBin === 0 || maxPower === 0) return null;

                const heartRateHz = maxFreqBin * sampleRate / N;
                const heartRateBPM = heartRateHz * 60;

                return { bpm: heartRateBPM, confidence: maxPower };
            } catch (error) {
                console.error('FFTè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // HRVå‘¨æ³¢æ•°è§£æï¼ˆLF/HFè¨ˆç®—ï¼‰
        function analyzeHRVFrequency(ppiValues) {
            try {
                if (!ppiValues || ppiValues.length < 30) {
                    console.log('HRVè§£æ: ãƒ‡ãƒ¼ã‚¿ä¸è¶³ï¼ˆæœ€ä½30å€‹ã®PPIãŒå¿…è¦ï¼‰');
                    return null;
                }

                console.log('HRVå‘¨æ³¢æ•°è§£æé–‹å§‹: PPIæ•°=', ppiValues.length);

                // PPIã‚’ç­‰é–“éš”ã«ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆ4Hz = 0.25ç§’é–“éš”ï¼‰
                const resampleRate = 4; // Hz
                const resampleInterval = 1000 / resampleRate; // ms

                const firstTime = ppiValues[0].timestamp;
                const lastTime = ppiValues[ppiValues.length - 1].timestamp;
                const duration = lastTime - firstTime;
                const numSamples = Math.floor(duration / resampleInterval);

                if (numSamples < 64) {
                    console.log('HRVè§£æ: ãƒªã‚µãƒ³ãƒ—ãƒ«å¾Œã®ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³');
                    return null;
                }

                // ç·šå½¢è£œé–“ã§ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                const resampledPPI = [];
                for (let i = 0; i < numSamples; i++) {
                    const targetTime = firstTime + i * resampleInterval;
                    
                    // targetTimeã«æœ€ã‚‚è¿‘ã„2ã¤ã®PPIã‚’è¦‹ã¤ã‘ã¦ç·šå½¢è£œé–“
                    let before = null, after = null;
                    for (let j = 0; j < ppiValues.length - 1; j++) {
                        if (ppiValues[j].timestamp <= targetTime && ppiValues[j + 1].timestamp >= targetTime) {
                            before = ppiValues[j];
                            after = ppiValues[j + 1];
                            break;
                        }
                    }

                    if (before && after) {
                        const ratio = (targetTime - before.timestamp) / (after.timestamp - before.timestamp);
                        const interpolated = before.interval + ratio * (after.interval - before.interval);
                        resampledPPI.push(interpolated);
                    }
                }

                console.log('ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å®Œäº†: ã‚µãƒ³ãƒ—ãƒ«æ•°=', resampledPPI.length);

                // DCæˆåˆ†é™¤å»
                const mean = resampledPPI.reduce((a, b) => a + b, 0) / resampledPPI.length;
                const detrendedPPI = resampledPPI.map(x => x - mean);

                // FFTã®æº–å‚™ï¼ˆ2ã®ã¹ãä¹—ã«èª¿æ•´ï¼‰
                const fftSize = Math.pow(2, Math.floor(Math.log2(detrendedPPI.length)));
                const fftInput = detrendedPPI.slice(0, fftSize);

                console.log('FFTã‚µã‚¤ã‚º:', fftSize);

                // FFTå®Ÿè¡Œï¼ˆãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«è¨ˆç®—ï¼‰
                const powerSpectrum = [];
                for (let k = 0; k < fftSize / 2; k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < fftSize; n++) {
                        const angle = -2 * Math.PI * k * n / fftSize;
                        real += fftInput[n] * Math.cos(angle);
                        imag += fftInput[n] * Math.sin(angle);
                    }
                    const power = (real * real + imag * imag) / (fftSize * fftSize);
                    powerSpectrum.push(power);
                }

                // å‘¨æ³¢æ•°è»¸ã®ä½œæˆ
                const frequencies = [];
                for (let i = 0; i < powerSpectrum.length; i++) {
                    frequencies.push(i * resampleRate / fftSize);
                }

                // LFå¸¯åŸŸï¼ˆ0.04-0.15 Hzï¼‰ã®ãƒ‘ãƒ¯ãƒ¼
                let lfPower = 0;
                let lfCount = 0;
                for (let i = 0; i < frequencies.length; i++) {
                    if (frequencies[i] >= 0.04 && frequencies[i] <= 0.15) {
                        lfPower += powerSpectrum[i];
                        lfCount++;
                    }
                }

                // HFå¸¯åŸŸï¼ˆ0.15-0.40 Hzï¼‰ã®ãƒ‘ãƒ¯ãƒ¼
                let hfPower = 0;
                let hfCount = 0;
                for (let i = 0; i < frequencies.length; i++) {
                    if (frequencies[i] >= 0.15 && frequencies[i] <= 0.40) {
                        hfPower += powerSpectrum[i];
                        hfCount++;
                    }
                }

                // LF/HFæ¯”
                const lfhfRatio = hfPower > 0 ? lfPower / hfPower : 0;

                console.log('HRVè§£æçµæœ:', {
                    lfPower: lfPower.toFixed(2),
                    hfPower: hfPower.toFixed(2),
                    lfhfRatio: lfhfRatio.toFixed(2)
                });

                return {
                    lfPower: lfPower,
                    hfPower: hfPower,
                    lfhfRatio: lfhfRatio,
                    powerSpectrum: powerSpectrum,
                    frequencies: frequencies,
                    resampledPPI: resampledPPI
                };

            } catch (error) {
                console.error('HRVå‘¨æ³¢æ•°è§£æã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // è¨ˆæ¸¬æ™‚é–“ã«åŸºã¥ãä¿¡é ¼æ€§è©•ä¾¡
        function assessMeasurementReliability(durationSeconds) {
            const minutes = durationSeconds / 60;

            if (minutes < 2) {
                return {
                    level: 'å‚è€ƒå€¤',
                    class: 'low',
                    description: 'è¨ˆæ¸¬æ™‚é–“ãŒçŸ­ã„ãŸã‚ã€å‚è€ƒç¨‹åº¦ã®å€¤ã§ã™ã€‚ã‚ˆã‚Šæ­£ç¢ºãªæ¸¬å®šã«ã¯5åˆ†ä»¥ä¸Šæ¨å¥¨ã€‚',
                    score: 1
                };
            } else if (minutes < 5) {
                return {
                    level: 'ç°¡æ˜“è©•ä¾¡',
                    class: 'medium',
                    description: 'ç°¡æ˜“çš„ãªè©•ä¾¡ãŒå¯èƒ½ã§ã™ã€‚æ¨™æº–æ¸¬å®šã«ã¯5åˆ†ä»¥ä¸Šã‚’æ¨å¥¨ã—ã¾ã™ã€‚',
                    score: 2
                };
            } else if (minutes < 10) {
                return {
                    level: 'æ¨™æº–æ¸¬å®š',
                    class: 'good',
                    description: 'æ¨å¥¨ã•ã‚Œã‚‹è¨ˆæ¸¬æ™‚é–“ã§ã™ã€‚ä¿¡é ¼æ€§ã®é«˜ã„è©•ä¾¡ãŒå¯èƒ½ã§ã™ã€‚',
                    score: 3
                };
            } else {
                return {
                    level: 'é«˜ç²¾åº¦æ¸¬å®š',
                    class: 'excellent',
                    description: 'ååˆ†ãªè¨ˆæ¸¬æ™‚é–“ã§ã™ã€‚ç ”ç©¶ãƒ¬ãƒ™ãƒ«ã®é«˜ç²¾åº¦ãªè©•ä¾¡ãŒå¯èƒ½ã§ã™ã€‚',
                    score: 4
                };
            }
        }

        // è¨ˆæ¸¬æ™‚é–“ã®æ›´æ–°ã¨è¡¨ç¤º
        function updateMeasurementTimer() {
            if (!isRecording || !startTime) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
            const timerDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timerValue').textContent = timerDisplay;

            // é€²æ—ãƒãƒ¼æ›´æ–°ï¼ˆ5åˆ†ã‚’100%ã¨ã—ã¦ï¼‰
            const targetSeconds = 300; // 5åˆ†
            const progress = Math.min((elapsed / targetSeconds) * 100, 100);
            document.getElementById('timerProgressFill').style.width = progress + '%';

            // æ¨å¥¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ›´æ–°
            const recommendation = document.getElementById('timerRecommendation');
            if (elapsed < 120) {
                recommendation.textContent = 'ç›®æ¨™: 5åˆ†ï¼ˆæ¨™æº–æ¸¬å®šï¼‰';
                recommendation.classList.remove('reached');
            } else if (elapsed < 300) {
                recommendation.textContent = `ã‚ã¨${Math.ceil((300 - elapsed) / 60)}åˆ†ã§æ¨™æº–æ¸¬å®šé”æˆ`;
                recommendation.classList.remove('reached');
            } else if (elapsed < 600) {
                recommendation.textContent = 'âœ“ æ¨™æº–æ¸¬å®šé”æˆï¼ 10åˆ†ã§ã•ã‚‰ã«é«˜ç²¾åº¦ã«';
                recommendation.classList.add('reached');
            } else {
                recommendation.textContent = 'âœ“ é«˜ç²¾åº¦æ¸¬å®šé”æˆï¼';
                recommendation.classList.add('reached');
            }
        }

        // ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹ã®åˆ¤å®š
        function assessStressLevel(lfhfRatio) {
            // LF/HFæ¯”ã«åŸºã¥ãã‚¹ãƒˆãƒ¬ã‚¹åˆ¤å®š
            // ä¸€èˆ¬çš„ãªåŸºæº–å€¤:
            // < 1.0: ãƒªãƒ©ãƒƒã‚¯ã‚¹
            // 1.0-2.0: æ­£å¸¸
            // 2.0-4.0: è»½åº¦ã‚¹ãƒˆãƒ¬ã‚¹
            // > 4.0: é«˜ã‚¹ãƒˆãƒ¬ã‚¹

            if (lfhfRatio < 1.0) {
                return {
                    level: 'ãƒªãƒ©ãƒƒã‚¯ã‚¹',
                    class: 'relaxed',
                    description: 'å‰¯äº¤æ„Ÿç¥çµŒãŒå„ªä½ã§ã™ã€‚ãƒªãƒ©ãƒƒã‚¯ã‚¹ã—ãŸçŠ¶æ…‹ã§ã™ã€‚'
                };
            } else if (lfhfRatio < 2.0) {
                return {
                    level: 'æ­£å¸¸',
                    class: 'normal',
                    description: 'äº¤æ„Ÿç¥çµŒã¨å‰¯äº¤æ„Ÿç¥çµŒã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯å¥½ã§ã™ã€‚'
                };
            } else if (lfhfRatio < 4.0) {
                return {
                    level: 'è»½åº¦ã‚¹ãƒˆãƒ¬ã‚¹',
                    class: 'stressed',
                    description: 'äº¤æ„Ÿç¥çµŒãŒã‚„ã‚„å„ªä½ã§ã™ã€‚è»½ã„ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚'
                };
            } else {
                return {
                    level: 'é«˜ã‚¹ãƒˆãƒ¬ã‚¹',
                    class: 'very-stressed',
                    description: 'äº¤æ„Ÿç¥çµŒãŒå¼·ãå„ªä½ã§ã™ã€‚é«˜ã„ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ…‹ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚'
                };
            }
        }

        // PPIï¼ˆPeak to Peak Intervalï¼‰è¨ˆç®—
        function calculatePPI(signal, sampleRate, timestamps) {
            try {
                if (signal.length < 50) return null;

                // ãƒ”ãƒ¼ã‚¯æ¤œå‡º
                const peaks = [];
                const maxVal = Math.max(...signal.filter(x => isFinite(x)));
                const minVal = Math.min(...signal.filter(x => isFinite(x)));
                const threshold = minVal + (maxVal - minVal) * 0.6;

                for (let i = 1; i < signal.length - 1; i++) {
                    if (signal[i] > threshold && 
                        signal[i] > signal[i - 1] && 
                        signal[i] > signal[i + 1]) {
                        // è¿‘æ¥ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹ï¼ˆæœ€ä½0.3ç§’é–“éš”ï¼‰
                        if (peaks.length === 0 || i - peaks[peaks.length - 1].index > sampleRate * 0.3) {
                            peaks.push({
                                index: i,
                                timestamp: timestamps[i],
                                value: signal[i]
                            });
                        }
                    }
                }

                if (peaks.length < 2) return null;

                // PPIï¼ˆãƒ”ãƒ¼ã‚¯é–“éš”ï¼‰ã‚’è¨ˆç®—
                const ppiValues = [];
                for (let i = 1; i < peaks.length; i++) {
                    const interval = peaks[i].timestamp - peaks[i - 1].timestamp; // ãƒŸãƒªç§’
                    const intervalSec = interval / 1000; // ç§’
                    
                    // ç”Ÿç†å­¦çš„ã«å¦¥å½“ãªç¯„å›²ï¼ˆ0.4ç§’ã€œ2.0ç§’ = 30ã€œ150 BPMï¼‰
                    if (intervalSec > 0.4 && intervalSec < 2.0) {
                        ppiValues.push({
                            interval: interval, // ãƒŸãƒªç§’
                            timestamp: peaks[i].timestamp,
                            bpm: 60 / intervalSec // ç¬æ™‚å¿ƒæ‹æ•°
                        });
                    }
                }

                if (ppiValues.length === 0) return null;

                // çµ±è¨ˆæƒ…å ±ã‚’è¨ˆç®—
                const intervals = ppiValues.map(p => p.interval);
                const meanPPI = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const sdPPI = Math.sqrt(
                    intervals.reduce((sum, val) => sum + Math.pow(val - meanPPI, 2), 0) / intervals.length
                );
                
                // RMSSDï¼ˆé€£ç¶šã™ã‚‹PPIå·®ã®äºŒä¹—å¹³å‡å¹³æ–¹æ ¹ï¼‰- HRVã®æŒ‡æ¨™
                let rmssd = 0;
                if (intervals.length > 1) {
                    const squaredDiffs = [];
                    for (let i = 1; i < intervals.length; i++) {
                        squaredDiffs.push(Math.pow(intervals[i] - intervals[i - 1], 2));
                    }
                    rmssd = Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / squaredDiffs.length);
                }

                return {
                    ppiValues: ppiValues,
                    peaks: peaks,
                    meanPPI: meanPPI,
                    sdPPI: sdPPI,
                    rmssd: rmssd,
                    avgBPM: 60000 / meanPPI // å¹³å‡å¿ƒæ‹æ•°
                };

            } catch (error) {
                console.error('PPIè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }
            try {
                if (signal.length < 20) return null;

                // ãƒ”ãƒ¼ã‚¯æ¤œå‡º
                const peaks = [];
                const maxVal = Math.max(...signal.filter(x => isFinite(x)));
                const minVal = Math.min(...signal.filter(x => isFinite(x)));
                const threshold = minVal + (maxVal - minVal) * 0.6;

                for (let i = 1; i < signal.length - 1; i++) {
                    if (signal[i] > threshold && 
                        signal[i] > signal[i - 1] && 
                        signal[i] > signal[i + 1]) {
                        // è¿‘æ¥ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹
                        if (peaks.length === 0 || i - peaks[peaks.length - 1] > sampleRate * 0.3) {
                            peaks.push(i);
                        }
                    }
                }

                if (peaks.length < 3) return null;

                // ãƒ”ãƒ¼ã‚¯é–“éš”ã‹ã‚‰å¿ƒæ‹è¨ˆç®—
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    const interval = (peaks[i] - peaks[i - 1]) / sampleRate;
                    if (interval > 0.4 && interval < 2.0) { // 30-150 BPM
                        intervals.push(interval);
                    }
                }

                if (intervals.length === 0) return null;

                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const bpm = 60 / avgInterval;
                
                return { bpm: bpm, confidence: peaks.length };
            } catch (error) {
                console.error('ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // è‡ªå·±ç›¸é–¢ã«ã‚ˆã‚‹å¿ƒæ‹æ¨å®š
        function autocorrelationHeartRate(signal, sampleRate) {
            try {
                if (signal.length < 50) return null;

                const minLag = Math.floor(sampleRate * 0.4); // 150 BPM
                const maxLag = Math.floor(sampleRate * 2.0); // 30 BPM

                let maxCorr = 0;
                let bestLag = 0;

                for (let lag = minLag; lag < maxLag && lag < signal.length / 2; lag++) {
                    let correlation = 0;
                    let count = 0;
                    for (let i = 0; i < signal.length - lag; i++) {
                        if (isFinite(signal[i]) && isFinite(signal[i + lag])) {
                            correlation += signal[i] * signal[i + lag];
                            count++;
                        }
                    }
                    if (count > 0) {
                        correlation /= count;
                    }
                    if (correlation > maxCorr) {
                        maxCorr = correlation;
                        bestLag = lag;
                    }
                }

                if (bestLag === 0 || maxCorr === 0) return null;

                const bpm = 60 * sampleRate / bestLag;
                
                // BPMãŒå¦¥å½“ãªç¯„å›²ã‹ãƒã‚§ãƒƒã‚¯
                if (bpm < 30 || bpm > 200) return null;
                
                return { bpm: bpm, confidence: maxCorr };
            } catch (error) {
                console.error('è‡ªå·±ç›¸é–¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // å¿ƒæ‹è§£æ
        function analyzeHeartRate() {
            try {
                if (accelerometerData.length < 50) {
                    return;
                }

                // å‰å‡¦ç†
                const processedSignal = preprocessSignal(accelerometerData);
                if (processedSignal.length < 20) return;

                // å‰å‡¦ç†æ¸ˆã¿ä¿¡å·ã‚’ä¿å­˜ï¼ˆåœæ­¢å¾Œã®è¡¨ç¤ºç”¨ï¼‰
                processedSignalData = processedSignal;

                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—é…åˆ—ã‚’ä½œæˆ
                const timestamps = accelerometerData.map(d => d.timestamp);

                // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
                const avgSampleRate = sampleRates.length > 0 
                    ? sampleRates.reduce((a, b) => a + b, 0) / sampleRates.length 
                    : 100;

                if (!isFinite(avgSampleRate) || avgSampleRate < 10) {
                    console.log('ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆãŒä¸æ­£:', avgSampleRate);
                    return;
                }

                // PPIè¨ˆç®—
                const ppiResult = calculatePPI(processedSignal, avgSampleRate, timestamps);
                
                if (ppiResult) {
                    // PPIãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    ppiData = ppiResult.ppiValues;
                    
                    // PPIæƒ…å ±ã‚’è¡¨ç¤º
                    document.getElementById('heartRate').textContent = Math.round(ppiResult.avgBPM);
                    document.getElementById('meanPPI').textContent = Math.round(ppiResult.meanPPI) + ' ms';
                    document.getElementById('rmssd').textContent = Math.round(ppiResult.rmssd) + ' ms';
                    
                    // ä¿¡å·å“è³ªã®è¡¨ç¤ºï¼ˆãƒ”ãƒ¼ã‚¯æ•°ã§åˆ¤å®šï¼‰
                    const quality = ppiResult.peaks.length > 10 ? 'è‰¯å¥½' : 
                                   ppiResult.peaks.length > 5 ? 'æ™®é€š' : 'ä½';
                    document.getElementById('signalQuality').textContent = quality;
                    
                    console.log('PPIè¨ˆç®—çµæœ:', {
                        avgBPM: Math.round(ppiResult.avgBPM),
                        meanPPI: Math.round(ppiResult.meanPPI),
                        sdPPI: Math.round(ppiResult.sdPPI),
                        rmssd: Math.round(ppiResult.rmssd),
                        peakCount: ppiResult.peaks.length,
                        ppiCount: ppiResult.ppiValues.length
                    });
                }

                const method = document.getElementById('detectionMethod').value;
                let result = null;

                // é¸æŠã•ã‚ŒãŸæ–¹æ³•ã§å¿ƒæ‹æ¨å®šï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
                switch (method) {
                    case 'peak':
                        result = peakDetectionHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'autocorr':
                        result = autocorrelationHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'fft':
                        result = fftHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'hybrid':
                        // PPIãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’å„ªå…ˆ
                        if (ppiResult) {
                            result = { bpm: ppiResult.avgBPM, confidence: ppiResult.peaks.length };
                        } else {
                            // è¤‡æ•°ã®æ–¹æ³•ã‚’çµ„ã¿åˆã‚ã›
                            const r1 = peakDetectionHeartRate(processedSignal, avgSampleRate);
                            const r2 = autocorrelationHeartRate(processedSignal, avgSampleRate);
                            const r3 = fftHeartRate(processedSignal, avgSampleRate);
                            
                            const results = [r1, r2, r3].filter(r => r !== null && isFinite(r.bpm));
                            if (results.length > 0) {
                                // ä¸­å¤®å€¤ã‚’ä½¿ç”¨ï¼ˆå¤–ã‚Œå€¤ã«å¼·ã„ï¼‰
                                const bpms = results.map(r => r.bpm).sort((a, b) => a - b);
                                const medianBpm = bpms[Math.floor(bpms.length / 2)];
                                const totalConf = results.reduce((sum, r) => sum + r.confidence, 0);
                                result = { bpm: medianBpm, confidence: totalConf / results.length };
                            }
                        }
                        break;
                }

                if (result && isFinite(result.bpm) && result.bpm >= 40 && result.bpm <= 180) {
                    // PPIãŒãªã„å ´åˆã®ã¿ã€å¾“æ¥ã®æ–¹æ³•ã§è¡¨ç¤º
                    if (!ppiResult) {
                        document.getElementById('heartRate').textContent = Math.round(result.bpm);
                        
                        // ä¿¡å·å“è³ªã®è¡¨ç¤º
                        const quality = result.confidence > 100 ? 'è‰¯å¥½' : 
                                       result.confidence > 50 ? 'æ™®é€š' : 'ä½';
                        document.getElementById('signalQuality').textContent = quality;
                    }
                } else {
                    console.log('ç„¡åŠ¹ãªå¿ƒæ‹æ•°:', result);
                }

                // æ³¢å½¢æç”»
                drawWaveform(processedSignal);
            } catch (error) {
                console.error('å¿ƒæ‹è§£æã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // æ³¢å½¢æç”»
        function drawWaveform(signal) {
            try {
                if (!ctx || !canvas) {
                    console.warn('CanvasæœªåˆæœŸåŒ–');
                    return;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!signal || signal.length < 2) return;

                const displayPoints = Math.min(signal.length, 300);
                const step = signal.length / displayPoints;
                
                // æ­£è¦åŒ–
                const validSignal = signal.filter(x => isFinite(x));
                if (validSignal.length === 0) return;
                
                const maxAbs = Math.max(...validSignal.map(Math.abs));
                if (maxAbs === 0 || !isFinite(maxAbs)) return;
                
                const normalized = signal.map(x => isFinite(x) ? x / maxAbs : 0);

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                let firstPoint = true;
                for (let i = 0; i < displayPoints; i++) {
                    const idx = Math.floor(i * step);
                    if (idx >= normalized.length) break;
                    
                    const x = (i / displayPoints) * canvas.width;
                    const y = canvas.height / 2 - (normalized[idx] * canvas.height * 0.4);
                    
                    if (!isFinite(x) || !isFinite(y)) continue;
                    
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();

                // ä¸­å¤®ç·š
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            } catch (error) {
                console.error('æ³¢å½¢æç”»ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // UIæ›´æ–°
        function updateUI() {
            if (!isRecording) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('duration').textContent = elapsed + 'ç§’';
            document.getElementById('dataPoints').textContent = accelerometerData.length;
            
            const avgSampleRate = sampleRates.length > 0 
                ? Math.round(sampleRates.reduce((a, b) => a + b, 0) / sampleRates.length)
                : 0;
            document.getElementById('sampleRate').textContent = avgSampleRate + ' Hz';

            // è¨ˆæ¸¬ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
            updateMeasurementTimer();

            requestAnimationFrame(updateUI);
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportData() {
            if (accelerometerData.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // åŠ é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã®CSV
            let csvAccel = 'timestamp,x,y,z,magnitude\n';
            accelerometerData.forEach(d => {
                csvAccel += `${d.timestamp},${d.x},${d.y},${d.z},${d.magnitude}\n`;
            });

            // PPIãƒ‡ãƒ¼ã‚¿ã®CSV
            let csvPPI = 'timestamp,interval_ms,bpm\n';
            ppiData.forEach(p => {
                csvPPI += `${p.timestamp},${p.interval},${p.bpm}\n`;
            });

            // 2ã¤ã®CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ZIPå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆç°¡æ˜“ç‰ˆï¼šå€‹åˆ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰
            
            // åŠ é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blobAccel = new Blob([csvAccel], { type: 'text/csv' });
            const urlAccel = URL.createObjectURL(blobAccel);
            const aAccel = document.createElement('a');
            aAccel.href = urlAccel;
            aAccel.download = `acceleration_data_${Date.now()}.csv`;
            aAccel.click();
            URL.revokeObjectURL(urlAccel);

            // PPIãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°ï¼‰
            if (ppiData.length > 0) {
                setTimeout(() => {
                    const blobPPI = new Blob([csvPPI], { type: 'text/csv' });
                    const urlPPI = URL.createObjectURL(blobPPI);
                    const aPPI = document.createElement('a');
                    aPPI.href = urlPPI;
                    aPPI.download = `ppi_data_${Date.now()}.csv`;
                    aPPI.click();
                    URL.revokeObjectURL(urlPPI);
                }, 500);
            }

            console.log('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†:', {
                accelerationPoints: accelerometerData.length,
                ppiPoints: ppiData.length
            });
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            console.log('========================================');
            console.log('ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†');
            console.log('ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—:', new Date().toISOString());
            console.log('User Agent:', navigator.userAgent);
            console.log('ãƒ—ãƒ­ãƒˆã‚³ãƒ«:', window.location.protocol);
            console.log('ãƒ›ã‚¹ãƒˆ:', window.location.hostname);
            console.log('========================================');
            
            // CanvasåˆæœŸåŒ–
            canvas = document.getElementById('waveform');
            if (canvas) {
                ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth * 2;
                canvas.height = 300;
                console.log('CanvasåˆæœŸåŒ–æˆåŠŸ');
            } else {
                console.error('Canvasè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            // ãƒœã‚¿ãƒ³ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            const startBtn = document.getElementById('startBtn');
            console.log('é–‹å§‹ãƒœã‚¿ãƒ³è¦ç´ :', startBtn);
            console.log('é–‹å§‹ãƒœã‚¿ãƒ³ disabled:', startBtn ? startBtn.disabled : 'ãƒœã‚¿ãƒ³ãªã—');
            
            // HTTPS ãƒã‚§ãƒƒã‚¯
            const isSecure = window.location.protocol === 'https:' || 
                           window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1' ||
                           window.location.protocol === 'file:' ||
                           window.location.hostname === '';
            
            console.log('ã‚»ã‚­ãƒ¥ã‚¢æ¥ç¶šåˆ¤å®š:', isSecure);
            
            if (!isSecure) {
                document.getElementById('status').textContent = 'âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™';
                document.getElementById('status').style.background = 'rgba(255, 100, 100, 0.3)';
                console.warn('HTTPSæ¥ç¶šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚iOSã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚');
            }
            
            // ã‚»ãƒ³ã‚µãƒ¼ã®å¯ç”¨æ€§ãƒã‚§ãƒƒã‚¯
            if (!window.DeviceMotionEvent) {
                console.error('DeviceMotionEventãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                alert('ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã¯åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('status').textContent = 'ã‚»ãƒ³ã‚µãƒ¼éå¯¾å¿œ';
                return;
            }
            
            console.log('DeviceMotionEventåˆ©ç”¨å¯èƒ½');
            console.log('DeviceMotionEvent.requestPermission:', typeof DeviceMotionEvent.requestPermission);
            
            // iOS 13+ ã®ãƒã‚§ãƒƒã‚¯
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            console.log('iOSç’°å¢ƒ:', isIOS);
            
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                console.log('iOS 13+: requestPermission ãŒå¿…è¦ã§ã™');
                if (isSecure) {
                    document.getElementById('status').textContent = 'æº–å‚™å®Œäº†ï¼ˆiOS: é–‹å§‹æ™‚ã«è¨±å¯ãŒå¿…è¦ï¼‰';
                } else {
                    document.getElementById('status').textContent = 'âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ï¼ˆiOSï¼‰';
                    document.getElementById('status').style.background = 'rgba(255, 100, 100, 0.3)';
                }
            } else {
                console.log('Android/ãã®ä»–: requestPermission ä¸è¦');
                document.getElementById('status').textContent = 'æº–å‚™å®Œäº†';
            }

            // iOSç’°å¢ƒã®é€šçŸ¥
            if (isIOS) {
                console.log('iOSç’°å¢ƒã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
                if (!isSecure) {
                    setTimeout(() => {
                        alert('âš ï¸ é‡è¦\n\niOSã§ã¯ã€HTTPSæ¥ç¶šãŒå¿…é ˆã§ã™ã€‚\n\nç¾åœ¨ã®æ¥ç¶š: ' + window.location.protocol + '\n\nHTTPSçµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚');
                    }, 1000);
                }
            }
            
            console.log('========================================');
            console.log('åˆæœŸåŒ–å®Œäº†');
            console.log('========================================');
        });
    </script>
</body>
</html>
