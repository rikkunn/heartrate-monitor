<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿ƒæ‹è¨ˆæ¸¬ã‚¢ãƒ—ãƒªï¼ˆåŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ï¼‰</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 500px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 14px;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .status.active {
            background: rgba(76, 175, 80, 0.3);
        }

        .heart-rate-display {
            text-align: center;
            margin: 30px 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
        }

        .heart-rate-value {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .heart-rate-label {
            font-size: 18px;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .start-btn {
            background: #4CAF50;
            color: white;
        }

        .start-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #f44336;
            color: white;
        }

        .stop-btn:hover:not(:disabled) {
            background: #da190b;
            transform: translateY(-2px);
        }

        .export-btn {
            background: #2196F3;
            color: white;
        }

        .export-btn:hover:not(:disabled) {
            background: #0b7dda;
            transform: translateY(-2px);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            opacity: 0.8;
        }

        .info-value {
            font-weight: bold;
        }

        canvas {
            width: 100%;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .instructions h3 {
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .settings {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings h3 {
            margin-bottom: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        select, input[type="number"] {
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ«€ å¿ƒæ‹è¨ˆæ¸¬ã‚¢ãƒ—ãƒª</h1>
        <p class="subtitle">åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨ã—ãŸéæ¥è§¦è¨ˆæ¸¬</p>

        <div class="status" id="status">
            ã‚»ãƒ³ã‚µãƒ¼æœªèµ·å‹•
        </div>

        <div class="heart-rate-display">
            <div class="heart-rate-value" id="heartRate">--</div>
            <div class="heart-rate-label">BPM (æ‹/åˆ†)</div>
        </div>

        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">è¨ˆæ¸¬æ™‚é–“</span>
                <span class="info-value" id="duration">0ç§’</span>
            </div>
            <div class="info-row">
                <span class="info-label">ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ</span>
                <span class="info-value" id="sampleRate">-- Hz</span>
            </div>
            <div class="info-row">
                <span class="info-label">ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ</span>
                <span class="info-value" id="dataPoints">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">ä¿¡å·å“è³ª</span>
                <span class="info-value" id="signalQuality">--</span>
            </div>
        </div>

        <div class="settings">
            <h3>è¨­å®š</h3>
            <div class="setting-row">
                <label>æ¤œå‡ºæ–¹æ³•:</label>
                <select id="detectionMethod">
                    <option value="peak">ãƒ”ãƒ¼ã‚¯æ¤œå‡º</option>
                    <option value="autocorr">è‡ªå·±ç›¸é–¢</option>
                    <option value="fft">FFTï¼ˆå‘¨æ³¢æ•°è§£æï¼‰</option>
                    <option value="hybrid" selected>ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰</option>
                </select>
            </div>
            <div class="setting-row">
                <label>ãƒ•ã‚£ãƒ«ã‚¿å¼·åº¦:</label>
                <select id="filterStrength">
                    <option value="low">å¼±</option>
                    <option value="medium" selected>ä¸­</option>
                    <option value="high">å¼·</option>
                </select>
            </div>
            <div class="setting-row">
                <label>æ›´æ–°é–“éš”:</label>
                <select id="updateInterval">
                    <option value="2000">2ç§’</option>
                    <option value="3000" selected>3ç§’</option>
                    <option value="5000">5ç§’</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button class="start-btn" id="startBtn" onclick="startMeasurement()">è¨ˆæ¸¬é–‹å§‹</button>
            <button class="stop-btn" id="stopBtn" onclick="stopMeasurement()" disabled>åœæ­¢</button>
        </div>

        <button class="export-btn" id="exportBtn" onclick="exportData()" disabled>ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>

        <canvas id="waveform"></canvas>

        <div class="instructions">
            <h3>ğŸ“± ä½¿ç”¨æ–¹æ³•</h3>
            <ol>
                <li><strong>é‡è¦:</strong> HTTPSã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ï¼ˆiOSã®å ´åˆå¿…é ˆï¼‰</li>
                <li>ä»°å‘ã‘ã«å¯ã¦ã€èƒ¸ã®ä¸­å¤®ã«ã‚¹ãƒãƒ›ã‚’ç½®ã</li>
                <li>ã‚¹ãƒãƒ›ãŒå¿ƒè‡“ã®å‹•ãã§æŒ¯å‹•ã™ã‚‹ã‚ˆã†ã«ä½ç½®ã‚’èª¿æ•´</li>
                <li>ã€Œè¨ˆæ¸¬é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™</li>
                <li><strong>iOSã®å ´åˆ:</strong> ã‚»ãƒ³ã‚µãƒ¼ä½¿ç”¨è¨±å¯ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€Œè¨±å¯ã€ã‚’ã‚¿ãƒƒãƒ—</li>
                <li>é™ã‹ã«å‘¼å¸ã—ã€å‹•ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹</li>
                <li>10ã€œ20ç§’å¾Œã«å¿ƒæ‹æ•°ãŒè¡¨ç¤ºã•ã‚Œã‚‹</li>
            </ol>
            <div style="margin-top: 15px; padding: 10px; background: rgba(255, 200, 0, 0.2); border-radius: 5px;">
                <strong>âš ï¸ iOSä½¿ç”¨æ™‚ã®æ³¨æ„:</strong><br>
                â€¢ Safari ã¾ãŸã¯ Chrome ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„<br>
                â€¢ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™ï¼ˆlocalhostä»¥å¤–ï¼‰<br>
                â€¢ ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã¯å¿…ãšã€Œè¨±å¯ã€ã‚’é¸ã‚“ã§ãã ã•ã„<br>
                â€¢ æ‹’å¦ã—ãŸå ´åˆã¯ã€Safariã®è¨­å®šâ†’Webã‚µã‚¤ãƒˆã®è¨­å®šã‹ã‚‰å¤‰æ›´ã§ãã¾ã™
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let isRecording = false;
        let accelerometerData = [];
        let startTime = null;
        let animationFrame = null;
        let sensorInterval = null;
        let analysisInterval = null;
        let lastTimestamp = null;
        let sampleRates = [];

        // Canvasè¨­å®š
        const canvas = document.getElementById('waveform');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth * 2;
        canvas.height = 300;

        // åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®åˆæœŸåŒ–ã¨è¨ˆæ¸¬é–‹å§‹
        async function startMeasurement() {
            console.log('è¨ˆæ¸¬é–‹å§‹ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
            console.log('ç¾åœ¨ã®URL:', window.location.href);
            console.log('ãƒ—ãƒ­ãƒˆã‚³ãƒ«:', window.location.protocol);
            
            // HTTPSãƒã‚§ãƒƒã‚¯ï¼ˆlocalhostä»¥å¤–ï¼‰
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                alert('âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™\n\niOSã§ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€HTTPSçµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n\nå¯¾å‡¦æ³•:\n1. GitHub Pagesã€Netlifyã€Vercelãªã©ã«ãƒ‡ãƒ—ãƒ­ã‚¤\n2. ãƒ­ãƒ¼ã‚«ãƒ«HTTPSã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨\n3. ngrokãªã©ã®ãƒˆãƒ³ãƒãƒ«ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨');
                console.error('HTTPSæ¥ç¶šã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                // iOS 13+ ã®å ´åˆã¯è¨±å¯ãŒå¿…è¦
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    console.log('iOS: ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...');
                    document.getElementById('status').textContent = 'è¨±å¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„...';
                    
                    try {
                        const permission = await DeviceMotionEvent.requestPermission();
                        console.log('è¨±å¯çµæœ:', permission);
                        
                        if (permission !== 'granted') {
                            const message = 
                                'âŒ ã‚»ãƒ³ã‚µãƒ¼ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ\n\n' +
                                'å¯¾å‡¦æ³•:\n' +
                                '1. Safariã®è¨­å®šã‚’é–‹ã\n' +
                                '2. ä¸‹ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦ã€Œãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€â†’ã€Œãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚ªãƒªã‚¨ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¯ã‚»ã‚¹ã€ã‚’æ¢ã™\n' +
                                '3. ã“ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‚’ã€Œè¨±å¯ã€ã«å¤‰æ›´\n' +
                                '4. ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã€ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„\n\n' +
                                'ã¾ãŸã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã“ã®ãƒšãƒ¼ã‚¸ã‚’é–‹ãç›´ã—ã¦ãã ã•ã„ã€‚';
                            
                            alert(message);
                            console.error('è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ');
                            document.getElementById('status').textContent = 'ã‚»ãƒ³ã‚µãƒ¼ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ';
                            return;
                        }
                    } catch (permError) {
                        console.error('è¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', permError);
                        alert('è¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + permError.message + '\n\nHTTPSæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                        return;
                    }
                } else {
                    console.log('Android/ãã®ä»–: è¨±å¯ä¸è¦');
                }

                isRecording = true;
                accelerometerData = [];
                startTime = Date.now();
                lastTimestamp = Date.now();
                sampleRates = [];

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('exportBtn').disabled = true;
                document.getElementById('status').textContent = 'è¨ˆæ¸¬ä¸­... ãƒ‡ãƒ¼ã‚¿å¾…æ©Ÿä¸­';
                document.getElementById('status').classList.add('active');

                console.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²ã—ã¾ã™');
                // åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                window.addEventListener('devicemotion', handleMotionEvent, true);

                // ã‚»ãƒ³ã‚µãƒ¼ãŒå‹•ä½œã—ã¦ã„ã‚‹ã‹ç¢ºèª
                setTimeout(() => {
                    if (accelerometerData.length === 0) {
                        console.warn('5ç§’çµŒéã—ã¦ã‚‚ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¦ã„ã¾ã›ã‚“');
                        document.getElementById('status').textContent = 'âš ï¸ ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãªã—ï¼ˆã‚¹ãƒãƒ›ã‚’è»½ãå‹•ã‹ã—ã¦ã¿ã¦ãã ã•ã„ï¼‰';
                    } else {
                        console.log('ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ:', accelerometerData.length, 'ä»¶');
                        document.getElementById('status').textContent = 'âœ“ è¨ˆæ¸¬ä¸­ï¼ˆãƒ‡ãƒ¼ã‚¿å–å¾—OKï¼‰';
                    }
                }, 5000);

                // å®šæœŸçš„ãªå¿ƒæ‹è§£æ
                const updateInterval = parseInt(document.getElementById('updateInterval').value);
                analysisInterval = setInterval(analyzeHeartRate, updateInterval);

                // UIæ›´æ–°
                requestAnimationFrame(updateUI);

                console.log('è¨ˆæ¸¬é–‹å§‹å®Œäº†');

            } catch (error) {
                console.error('ã‚»ãƒ³ã‚µãƒ¼èµ·å‹•ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚»ãƒ³ã‚µãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message + '\n\nè©³ç´°ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                isRecording = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'ã‚¨ãƒ©ãƒ¼: ' + error.message;
            }
        }

        // åŠ é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
        function handleMotionEvent(event) {
            if (!isRecording) return;

            const acc = event.accelerationIncludingGravity;
            
            // åˆå›ã®ã¿ãƒ­ã‚°å‡ºåŠ›
            if (accelerometerData.length === 0) {
                console.log('åˆå›ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å—ä¿¡:', acc);
            }
            
            if (acc && acc.x !== null && acc.y !== null && acc.z !== null) {
                const timestamp = Date.now();
                
                // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
                if (lastTimestamp) {
                    const rate = 1000 / (timestamp - lastTimestamp);
                    sampleRates.push(rate);
                    if (sampleRates.length > 50) sampleRates.shift();
                }
                lastTimestamp = timestamp;

                // 3è»¸ã®åˆæˆåŠ é€Ÿåº¦ï¼ˆãƒãƒ«ãƒ ï¼‰
                const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
                
                accelerometerData.push({
                    timestamp: timestamp,
                    x: acc.x,
                    y: acc.y,
                    z: acc.z,
                    magnitude: magnitude
                });

                // 100ä»¶ã”ã¨ã«ãƒ­ã‚°
                if (accelerometerData.length % 100 === 0) {
                    console.log('ãƒ‡ãƒ¼ã‚¿ä»¶æ•°:', accelerometerData.length, 'å¹³å‡ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ:', 
                        Math.round(sampleRates.reduce((a,b) => a+b, 0) / sampleRates.length), 'Hz');
                }

                // ãƒ¡ãƒ¢ãƒªç®¡ç†ï¼š30ç§’ä»¥ä¸Šå¤ã„ãƒ‡ãƒ¼ã‚¿ã¯å‰Šé™¤
                const cutoffTime = timestamp - 30000;
                accelerometerData = accelerometerData.filter(d => d.timestamp > cutoffTime);
            } else {
                // ãƒ‡ãƒ¼ã‚¿ãŒnullã®å ´åˆ
                if (accelerometerData.length < 5) {
                    console.warn('ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒnullã§ã™:', acc);
                }
            }
        }

        // è¨ˆæ¸¬åœæ­¢
        function stopMeasurement() {
            console.log('è¨ˆæ¸¬åœæ­¢');
            isRecording = false;
            window.removeEventListener('devicemotion', handleMotionEvent, true);
            
            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            }

            console.log('æœ€çµ‚ãƒ‡ãƒ¼ã‚¿ä»¶æ•°:', accelerometerData.length);

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('status').textContent = 'è¨ˆæ¸¬åœæ­¢ï¼ˆãƒ‡ãƒ¼ã‚¿: ' + accelerometerData.length + 'ä»¶ï¼‰';
            document.getElementById('status').classList.remove('active');
        }

        // å‰å‡¦ç†ï¼šDCé™¤å»ã¨å¸¯åŸŸãƒ•ã‚£ãƒ«ã‚¿
        function preprocessSignal(data) {
            try {
                if (data.length < 10) return [];

                // åŠ é€Ÿåº¦ã®ãƒãƒ«ãƒ ã‚’ä½¿ç”¨
                let signal = data.map(d => d.magnitude).filter(x => isFinite(x));
                
                if (signal.length < 10) return [];

                // DCæˆåˆ†é™¤å»ï¼ˆå¹³å‡ã‚’å¼•ãï¼‰
                const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
                signal = signal.map(x => x - mean);

                // ç°¡æ˜“çš„ãªãƒãƒ³ãƒ‰ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆ0.7Hz - 4Hzï¼šå¿ƒæ‹ã®å‘¨æ³¢æ•°å¸¯åŸŸï¼‰
                const filterStrength = document.getElementById('filterStrength').value;
                const windowSize = filterStrength === 'low' ? 3 : filterStrength === 'high' ? 7 : 5;
                
                // ç§»å‹•å¹³å‡ã«ã‚ˆã‚‹é«˜å‘¨æ³¢ãƒã‚¤ã‚ºé™¤å»
                let filtered = [];
                for (let i = 0; i < signal.length; i++) {
                    let sum = 0;
                    let count = 0;
                    const halfWindow = Math.floor(windowSize / 2);
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(signal.length - 1, i + halfWindow); j++) {
                        if (isFinite(signal[j])) {
                            sum += signal[j];
                            count++;
                        }
                    }
                    if (count > 0) {
                        filtered.push(sum / count);
                    }
                }

                return filtered.filter(x => isFinite(x));
            } catch (error) {
                console.error('å‰å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                return [];
            }
        }

        // FFTã‚’ä½¿ã£ãŸå‘¨æ³¢æ•°è§£æ
        function fftHeartRate(signal, sampleRate) {
            try {
                if (signal.length < 64) return null;

                // FFTï¼ˆç°¡æ˜“ç‰ˆ - DFTå®Ÿè£…ï¼‰
                const N = Math.min(256, Math.pow(2, Math.floor(Math.log2(signal.length))));
                const fft = new Array(N).fill(0);
                
                // è¨ˆç®—è² è·ã‚’æ¸›ã‚‰ã™ãŸã‚ã€ä¸€éƒ¨ã®å‘¨æ³¢æ•°ã®ã¿è¨ˆç®—
                const minFreq = 0.7;
                const maxFreq = 4.0;
                const minBin = Math.floor(minFreq * N / sampleRate);
                const maxBin = Math.ceil(maxFreq * N / sampleRate);

                for (let k = minBin; k < maxBin && k < N; k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < N && n < signal.length; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += signal[n] * Math.cos(angle);
                        imag += signal[n] * Math.sin(angle);
                    }
                    fft[k] = Math.sqrt(real * real + imag * imag);
                }

                // æœ€å¤§ãƒ‘ãƒ¯ãƒ¼ã®å‘¨æ³¢æ•°ã‚’æ¤œå‡º
                let maxPower = 0;
                let maxFreqBin = 0;
                for (let i = minBin; i < maxBin && i < fft.length; i++) {
                    if (fft[i] > maxPower) {
                        maxPower = fft[i];
                        maxFreqBin = i;
                    }
                }

                if (maxFreqBin === 0 || maxPower === 0) return null;

                const heartRateHz = maxFreqBin * sampleRate / N;
                const heartRateBPM = heartRateHz * 60;

                return { bpm: heartRateBPM, confidence: maxPower };
            } catch (error) {
                console.error('FFTè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã«ã‚ˆã‚‹å¿ƒæ‹æ¨å®š
        function peakDetectionHeartRate(signal, sampleRate) {
            try {
                if (signal.length < 20) return null;

                // ãƒ”ãƒ¼ã‚¯æ¤œå‡º
                const peaks = [];
                const maxVal = Math.max(...signal.filter(x => isFinite(x)));
                const minVal = Math.min(...signal.filter(x => isFinite(x)));
                const threshold = minVal + (maxVal - minVal) * 0.6;

                for (let i = 1; i < signal.length - 1; i++) {
                    if (signal[i] > threshold && 
                        signal[i] > signal[i - 1] && 
                        signal[i] > signal[i + 1]) {
                        // è¿‘æ¥ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹
                        if (peaks.length === 0 || i - peaks[peaks.length - 1] > sampleRate * 0.3) {
                            peaks.push(i);
                        }
                    }
                }

                if (peaks.length < 3) return null;

                // ãƒ”ãƒ¼ã‚¯é–“éš”ã‹ã‚‰å¿ƒæ‹è¨ˆç®—
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    const interval = (peaks[i] - peaks[i - 1]) / sampleRate;
                    if (interval > 0.4 && interval < 2.0) { // 30-150 BPM
                        intervals.push(interval);
                    }
                }

                if (intervals.length === 0) return null;

                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const bpm = 60 / avgInterval;
                
                return { bpm: bpm, confidence: peaks.length };
            } catch (error) {
                console.error('ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // è‡ªå·±ç›¸é–¢ã«ã‚ˆã‚‹å¿ƒæ‹æ¨å®š
        function autocorrelationHeartRate(signal, sampleRate) {
            try {
                if (signal.length < 50) return null;

                const minLag = Math.floor(sampleRate * 0.4); // 150 BPM
                const maxLag = Math.floor(sampleRate * 2.0); // 30 BPM

                let maxCorr = 0;
                let bestLag = 0;

                for (let lag = minLag; lag < maxLag && lag < signal.length / 2; lag++) {
                    let correlation = 0;
                    let count = 0;
                    for (let i = 0; i < signal.length - lag; i++) {
                        if (isFinite(signal[i]) && isFinite(signal[i + lag])) {
                            correlation += signal[i] * signal[i + lag];
                            count++;
                        }
                    }
                    if (count > 0) {
                        correlation /= count;
                    }
                    if (correlation > maxCorr) {
                        maxCorr = correlation;
                        bestLag = lag;
                    }
                }

                if (bestLag === 0 || maxCorr === 0) return null;

                const bpm = 60 * sampleRate / bestLag;
                
                // BPMãŒå¦¥å½“ãªç¯„å›²ã‹ãƒã‚§ãƒƒã‚¯
                if (bpm < 30 || bpm > 200) return null;
                
                return { bpm: bpm, confidence: maxCorr };
            } catch (error) {
                console.error('è‡ªå·±ç›¸é–¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // å¿ƒæ‹è§£æ
        function analyzeHeartRate() {
            try {
                if (accelerometerData.length < 50) {
                    return;
                }

                // å‰å‡¦ç†
                const processedSignal = preprocessSignal(accelerometerData);
                if (processedSignal.length < 20) return;

                // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
                const avgSampleRate = sampleRates.length > 0 
                    ? sampleRates.reduce((a, b) => a + b, 0) / sampleRates.length 
                    : 50;

                if (!isFinite(avgSampleRate) || avgSampleRate < 10) {
                    console.log('ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆãŒä¸æ­£:', avgSampleRate);
                    return;
                }

                const method = document.getElementById('detectionMethod').value;
                let result = null;

                // é¸æŠã•ã‚ŒãŸæ–¹æ³•ã§å¿ƒæ‹æ¨å®š
                switch (method) {
                    case 'peak':
                        result = peakDetectionHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'autocorr':
                        result = autocorrelationHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'fft':
                        result = fftHeartRate(processedSignal, avgSampleRate);
                        break;
                    case 'hybrid':
                        // è¤‡æ•°ã®æ–¹æ³•ã‚’çµ„ã¿åˆã‚ã›
                        const r1 = peakDetectionHeartRate(processedSignal, avgSampleRate);
                        const r2 = autocorrelationHeartRate(processedSignal, avgSampleRate);
                        const r3 = fftHeartRate(processedSignal, avgSampleRate);
                        
                        const results = [r1, r2, r3].filter(r => r !== null && isFinite(r.bpm));
                        if (results.length > 0) {
                            // ä¸­å¤®å€¤ã‚’ä½¿ç”¨ï¼ˆå¤–ã‚Œå€¤ã«å¼·ã„ï¼‰
                            const bpms = results.map(r => r.bpm).sort((a, b) => a - b);
                            const medianBpm = bpms[Math.floor(bpms.length / 2)];
                            const totalConf = results.reduce((sum, r) => sum + r.confidence, 0);
                            result = { bpm: medianBpm, confidence: totalConf / results.length };
                        }
                        break;
                }

                if (result && isFinite(result.bpm) && result.bpm >= 40 && result.bpm <= 180) {
                    document.getElementById('heartRate').textContent = Math.round(result.bpm);
                    
                    // ä¿¡å·å“è³ªã®è¡¨ç¤º
                    const quality = result.confidence > 100 ? 'è‰¯å¥½' : 
                                   result.confidence > 50 ? 'æ™®é€š' : 'ä½';
                    document.getElementById('signalQuality').textContent = quality;
                } else {
                    console.log('ç„¡åŠ¹ãªå¿ƒæ‹æ•°:', result);
                }

                // æ³¢å½¢æç”»
                drawWaveform(processedSignal);
            } catch (error) {
                console.error('å¿ƒæ‹è§£æã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // æ³¢å½¢æç”»
        function drawWaveform(signal) {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!signal || signal.length < 2) return;

                const displayPoints = Math.min(signal.length, 300);
                const step = signal.length / displayPoints;
                
                // æ­£è¦åŒ–
                const validSignal = signal.filter(x => isFinite(x));
                if (validSignal.length === 0) return;
                
                const maxAbs = Math.max(...validSignal.map(Math.abs));
                if (maxAbs === 0 || !isFinite(maxAbs)) return;
                
                const normalized = signal.map(x => isFinite(x) ? x / maxAbs : 0);

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                let firstPoint = true;
                for (let i = 0; i < displayPoints; i++) {
                    const idx = Math.floor(i * step);
                    if (idx >= normalized.length) break;
                    
                    const x = (i / displayPoints) * canvas.width;
                    const y = canvas.height / 2 - (normalized[idx] * canvas.height * 0.4);
                    
                    if (!isFinite(x) || !isFinite(y)) continue;
                    
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();

                // ä¸­å¤®ç·š
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            } catch (error) {
                console.error('æ³¢å½¢æç”»ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // UIæ›´æ–°
        function updateUI() {
            if (!isRecording) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('duration').textContent = elapsed + 'ç§’';
            document.getElementById('dataPoints').textContent = accelerometerData.length;
            
            const avgSampleRate = sampleRates.length > 0 
                ? Math.round(sampleRates.reduce((a, b) => a + b, 0) / sampleRates.length)
                : 0;
            document.getElementById('sampleRate').textContent = avgSampleRate + ' Hz';

            requestAnimationFrame(updateUI);
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportData() {
            if (accelerometerData.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // CSVå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            let csv = 'timestamp,x,y,z,magnitude\n';
            accelerometerData.forEach(d => {
                csv += `${d.timestamp},${d.x},${d.y},${d.z},${d.magnitude}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `heartrate_data_${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            console.log('ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†');
            console.log('User Agent:', navigator.userAgent);
            console.log('ãƒ—ãƒ­ãƒˆã‚³ãƒ«:', window.location.protocol);
            console.log('ãƒ›ã‚¹ãƒˆ:', window.location.hostname);
            
            // HTTPS ãƒã‚§ãƒƒã‚¯
            const isSecure = window.location.protocol === 'https:' || 
                           window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1';
            
            if (!isSecure) {
                document.getElementById('status').textContent = 'âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™';
                document.getElementById('status').style.background = 'rgba(255, 100, 100, 0.3)';
                console.warn('HTTPSæ¥ç¶šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚iOSã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚');
            }
            
            // ã‚»ãƒ³ã‚µãƒ¼ã®å¯ç”¨æ€§ãƒã‚§ãƒƒã‚¯
            if (!window.DeviceMotionEvent) {
                console.error('DeviceMotionEventãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                alert('ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã¯åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('status').textContent = 'ã‚»ãƒ³ã‚µãƒ¼éå¯¾å¿œ';
                return;
            }
            
            console.log('DeviceMotionEventåˆ©ç”¨å¯èƒ½');
            
            // iOS 13+ ã®ãƒã‚§ãƒƒã‚¯
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                console.log('iOS 13+: requestPermission ãŒå¿…è¦ã§ã™');
                if (isSecure) {
                    document.getElementById('status').textContent = 'æº–å‚™å®Œäº†ï¼ˆiOS: é–‹å§‹æ™‚ã«è¨±å¯ãŒå¿…è¦ï¼‰';
                } else {
                    document.getElementById('status').textContent = 'âš ï¸ HTTPSæ¥ç¶šãŒå¿…è¦ï¼ˆiOSï¼‰';
                    document.getElementById('status').style.background = 'rgba(255, 100, 100, 0.3)';
                }
            } else {
                console.log('Android/ãã®ä»–: requestPermission ä¸è¦');
                document.getElementById('status').textContent = 'æº–å‚™å®Œäº†';
            }

            // iOSç’°å¢ƒã®é€šçŸ¥
            if (isIOS) {
                console.log('iOSç’°å¢ƒã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
                if (!isSecure) {
                    setTimeout(() => {
                        alert('âš ï¸ é‡è¦\n\niOSã§ã¯ã€HTTPSæ¥ç¶šãŒå¿…é ˆã§ã™ã€‚\n\nç¾åœ¨ã®æ¥ç¶š: ' + window.location.protocol + '\n\nHTTPSçµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚');
                    }, 1000);
                }
            }
        });
    </script>
</body>
</html>
